Sieve of Eratosthenes
에라토스테네스의 체는 특정 범위의 수들이 소수(Prime)인지 아닌지를 판별하는 알고리즘입니다. 에라토스테네스의 체의 원리는 간단합니다.

1~50까지 모든 소수를 구하고자 한다면, 먼저 아래와 같은 배열이 필요합니다. 이 배열은 해당 인덱스의 숫자가 소수인지 아닌지를 나타냅니다.


먼저 가장 작은 소수 2부터 시작합니다. 그리고 2의 배수에 해당하는 수들은 모두 소수가 아닙니다. 따라서 범위 안의 2의 배수들을 소수가 아니라고 체크해줍니다.(일반적으로 boolean타입이나 int형 변수를 만들어주어 체크) 아래에서 색이 칠해진 수는 소수가 아님을 나타냅니다.


다음은 3입니다. 3은 2의 배수가 아니므로 체크가 되어있지 않습니다. 따라서 3은 소수입니다. 아까 했던 방식처럼 범위 안의 3의 배수를 모두 소수가 아니라고 체크해줍니다.


다음은 4입니다. 4는 2의 배수를 체크할 때 체크된 숫자이므로 소수가 아닙니다. 따라서 그냥 넘어갑니다. 그러면 다음 수는 5입니다. 5는 체크된 숫자가 아니므로 소수입니다. 마찬가지로 5의 배수를 모두 체크 해줍니다.


다음 수인 6은 4와 마찬가지로 색이 칠해져 있습니다. 즉 6은 이미 어떤 소수의 배수였기 때문에 소수가 아니라는 것을 알 수 있습니다. 따라서 2부터 시작해서 구하고 싶은 최대값까지 차례대로 보며 남은 수 중 아직 지워지지 않은 가장 작은 값은 소수가 되며, 이 배수들을 지워나가면 우리는 범위 내의 모든 소수를 구할 수 있습니다.
위의 과정을 50까지 반복하면 배열은 아래와 같이 변하고, 이때 칠해지지 않은 수 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47이 1 ~ 50 범위에 속하는 소수가 됩니다.


위와 같은 방식으로 아주 작은 소수부터 시작해서 해당 수들의 배수를 제외시켜 나가는 알고리즘을 에라토스테네스의 체라고 합니다. 이를 수도코드로 나타내면 다음과 같습니다.

Boolean Array isPrime[N]={true, …,true}
For(i=2;i<=N;i++)
{
   If(isPrime[i] is false) continue
   For(j=i+i;j<=N;j+=i)
   {
    	isPrime[j]=false
   }
} 	

위의 코드는 최적화가 가능합니다. 첫 번째 반복문의 범위를 1부터 N까지가 아닌 1부터 sqrt(N)까지라고 한다면 정확성은 유지하면서 속도가 좀 더 빨라집니다. 어째서 N이 아닌 sqrt(N)까지로 하는지 의문이 들 수 있으므로 추가 설명하겠습니다.
제곱인 숫자 A가 있다고 가정합시다. 어떤 수 A의 약수의 개수는 홀수 개 입니다 (만약 이 수가 어떤 수의 제곱이 아니라면 짝수 개가 되겠죠). 그리고 A의 전체 약수 집합이 {a1, a2, a3, a4, a5, a6, a7, a8}이었다고 한다면 이는 A = a1*a8 = a2*a7 = a3*a6 = a4*a5로 나타낸 수 있습니다.
즉, 어떤 수 N을 약수로 나눈 몫 또한 약수가 되게 됩니다. 따라서 해당 수가 어떤 수의 제곱이라면 왼쪽 그림과 같이 표현할 수 있고, 아니라면 오른쪽 그림과 같이 표현할 수 있습니다.


그러면 A의 약수를 구할 때 1부터 A까지가 아닌 1부터 sqrt(A)까지 구해야 된다는 것은 자명합니다. 따라서 N이 소수인지 아닌지 확인하기 위해 N 까지 확인하면 N의 약수들의 배수들이 소수인지 판별되었다는 것 또한 자명하기 때문에 이 알고리즘은 위와 같이 최적화가 가능합니다.

Boolean Array isPrime[N]={true, …,true}
For(i=2;i<= sqrt(N);i++)
{
   If(isPrime[i] is false) continue
   For(j=i+i;j<=N;j+=i)
   {
    	isPrime[j]=false
   }
} 	

하지만 해당 범위 내에서 M번째 소수를 구하는 문제라면 위와 같이 최적화 해선 안됩니다. 위와 같이 최적화하고 범위 내의 소수를 구한다면 sqrt(N)까지 범위의 소수들만 구해지기 때문입니다. 따라서 해당 숫자가 소수인지 아닌지 판별할 경우에는 위와 같이 최적화하고 해당 소수를 출력하는 문제라면 최적화하지 않고 N까지 돌려야 합니다.

테스트케이스가 여러 개인 문제에서는 테스트케이스 입력 전에 한번만 위 알고리즘을 돌립니다. 매 케이스마다 돌릴 필요가 없으며 돌릴 경우 오버헤드가 크기 때문에 Time-Limit 발생할 수 있습니다.
